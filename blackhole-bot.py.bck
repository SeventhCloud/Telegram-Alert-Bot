import asyncio
from dexscreener import DexscreenerClient
from telegram import Bot
import logging # For better logging
import os

# --- Configuration ---
TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")

DEXSCREENER_CHAIN_ID = "avalanche"
DEXSCREENER_PAIR_ADDRESS = "0x859592A4A469610E573f96Ef87A0e5565F9a94c8"  # <<< REPLACE WITH ACTUAL PAIR ADDRESS

PRICE_THRESHOLD = 1.0003  # The price you want to monitor against (e.g., 1 USD)
CHECK_INTERVAL_SECONDS = 120  # Check every 120 seconds (2 minutes)
ALERT_COOLDOWN_SECONDS = 750 # Cooldown for 1 hour after an alert to prevent spamming

# --- Configure Logging ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# --- Initialize Dexscreener Client ---
# Use the async client for better compatibility with asyncio
dexscreener_client = DexscreenerClient()

# --- Initialize Telegram Bot ---
bot = Bot(token=TELEGRAM_BOT_TOKEN)

async def send_telegram_message(message_text: str):
    """Sends a message to the configured Telegram chat."""
    try:
        await bot.send_message(chat_id=TELEGRAM_CHAT_ID, text=message_text, parse_mode='HTML')
        logger.info(f"Notification sent to Telegram: {message_text}")
    except Exception as e:
        logger.error(f"Error sending Telegram message: {e}")

async def get_dex_pair_data():
    """
    Fetches the pair data from Dexscreener.
    Returns the pair data object or None if an error occurs or no data is found.
    """
    try:
        # Use the async method get_token_pair_async
        pairs_data = await dexscreener_client.get_token_pair_async(DEXSCREENER_CHAIN_ID, DEXSCREENER_PAIR_ADDRESS)

        if pairs_data and pairs_data.base_token and pairs_data.quote_token:
            logger.info(f"Successfully fetched data for {pairs_data.base_token.symbol}/{pairs_data.quote_token.symbol}.")
            # You can log more details if needed, but not necessarily on every check
            # logger.debug(f"Chain: {pairs_data.chain_id}")
            # logger.debug(f"DEX: {pairs_data.dex_id}")
            # logger.debug(f"Price Native: {pairs_data.price_native}")
            # logger.debug(f"Price USD: {pairs_data.price_usd}")
            return pairs_data
        else:
            logger.warning(f"No data found for pair {DEXSCREENER_PAIR_ADDRESS} on chain {DEXSCREENER_CHAIN_ID}.")
            return None
    except Exception as e:
        logger.error(f"An error occurred while fetching Dexscreener data: {e}")
        return None

async def monitor_price():
    """Monitors the price and sends alerts if it drops below the threshold."""
    logger.info(f"Starting price monitor for pair {DEXSCREENER_PAIR_ADDRESS} on {DEXSCREENER_CHAIN_ID}...")
    logger.info(f"Monitoring if base token price drops below ${PRICE_THRESHOLD}")

    last_alert_time = None  # To prevent spamming if price stays below threshold

    while True:
        pairs_data = await get_dex_pair_data()

        if pairs_data:
            current_price_native = pairs_data.price_native
            logger.info(f"{pairs_data.base_token.symbol}/{pairs_data.quote_token.symbol} - Current Price {pairs_data.quote_token.symbol}: ${current_price_native:.6f}")

            if current_price_native < PRICE_THRESHOLD:
                # Check if we've already alerted recently or if it's the first alert
                if last_alert_time is None or (asyncio.get_event_loop().time() - last_alert_time) > ALERT_COOLDOWN_SECONDS:
                    message = (
                        f"ðŸš¨ **PRICE ALERT!** ðŸš¨\n\n"
                        f"The price of {pairs_data.base_token.symbol} has dropped below ${PRICE_THRESHOLD}!\n"
                        f"Current Price: **${current_price_native:.6f} USD**\n"
                        f"Pool: <a href='{pairs_data.url}'>{pairs_data.base_token.symbol}/{pairs_data.quote_token.symbol} on {pairs_data.dex_id}</a>\n"
                        f"Chain: {pairs_data.chain_id.capitalize()}"
                    )
                    await send_telegram_message(message)
                    last_alert_time = asyncio.get_event_loop().time()  # Update last alert time
                else:
                    logger.info(f"Price below threshold, but still in cooldown period ({ALERT_COOLDOWN_SECONDS / 60} minutes remaining).")
            else:
                # If price is above threshold, reset the cooldown for the next drop
                if last_alert_time is not None:
                    logger.info("Price is back above threshold. Resetting alert cooldown.")
                    last_alert_time = None
        else:
            logger.warning("Skipping price check due to previous data fetching error.")

        await asyncio.sleep(CHECK_INTERVAL_SECONDS)  # Wait before the next check

async def main():
    await monitor_price()

if __name__ == "__main__":
    try:
        asyncio.run(main())
    except KeyboardInterrupt:
        logger.info("Bot stopped by user.")
    except Exception as e:
        logger.critical(f"Unhandled error in main: {e}")